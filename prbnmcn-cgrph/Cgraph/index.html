<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Cgraph (prbnmcn-cgrph.Cgraph)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">prbnmcn-cgrph</a> &#x00BB; Cgraph</nav><h1>Module <code>Cgraph</code></h1><p>Cgraph: a simple library for incremental computation</p><nav class="toc"><ul><li><a href="#introduction">Introduction</a></li><li><a href="#example">Example</a></li><li><a href="#api">API documentation</a></li></ul></nav></header><section><header><h2 id="introduction"><a href="#introduction" class="anchor"></a>Introduction</h2><p>The API exposed by Cgraph allows to construct a DAG where nodes hold functions. Users describe computations using this API; the library ensures that upon change of input, only the minimal amount of computation has to be performed to update the output. See the work by Umut Acar et al, and others for more details.</p></header></section><section><header><h2 id="example"><a href="#example" class="anchor"></a>Example</h2><p>We illustrate the library by considering the toy problem of evaluating an arithmetic expression. We consider a very simple data type, with just addition and negation. Variables are represented by strings and we'll use a string map to represent the environment in which the expression is evaluated.</p><pre><code class="ml">module String_map = Map.Make (String)

type expr = Var of string | Add of expr * expr | Neg of expr</code></pre><p>In the rest, we'll consider the following expression, corresponding to <code>(a + b) - (c + d)</code>.</p><pre><code class="ml">let expr = Add (Add (Var &quot;a&quot;, Var &quot;b&quot;), Neg (Add (Var &quot;c&quot;, Var &quot;d&quot;)))</code></pre><p>In order to trace the evaluation of the naive vs incrementalized evaluators, we instrument addition and negation with printfs.</p><pre><code class="ml">let ( + ) x y =
  Format.printf &quot;%d + %d@.&quot; x y ;
  x + y

let ( - ) x =
  Format.printf &quot;- %d@.&quot; x ;
  -x</code></pre><p>The <code>Non_incremental</code> module defines a straightforward evaluator for our small language and evaluates it, changing the value of the variable <code>&quot;a&quot;</code> the second time.</p><pre><code class="ml">let env l = String_map.of_seq (List.to_seq l)

module Non_incremental = struct
  let () = Format.printf &quot;Non incremental computation@.&quot;

  let rec eval (env : int String_map.t) expr =
    match expr with
    | Var s -&gt; String_map.find s env
    | Add (l, r) -&gt; eval env l + eval env r
    | Neg e -&gt; -eval env e

  let () = Format.printf &quot;First evaluation@.&quot;

  let () =
    assert (eval (env [(&quot;a&quot;, 1); (&quot;b&quot;, 2); (&quot;c&quot;, 3); (&quot;d&quot;, 4)]) expr = -4)

  let () = Format.printf &quot;Second evaluation@.&quot;

  let () =
    assert (eval (env [(&quot;a&quot;, 3); (&quot;b&quot;, 2); (&quot;c&quot;, 3); (&quot;d&quot;, 4)]) expr = -2)
end</code></pre><p>Evaluating this piece of code prints the following:</p><pre>    Non incremental computation
    First evaluation
    3 + 4
    1 + 2
    3 + -7
    Second evaluation
    3 + 4
    3 + 2
    5 + -7</pre><p>Let's reiterate the experiment, using the library.</p><pre><code class="ml">module Incremental = struct
  let () = Format.printf &quot;Incremental computation@.&quot;

  open Cgraph

  let rec eval (env : int t String_map.t) expr =
    match expr with
    | Var s -&gt; String_map.find s env
    | Add (l, r) -&gt; map2 (eval env l) (eval env r) ( + )
    | Neg e -&gt; map (eval env e) ( ~- )

  let (a, b, c, d) = (Var.create 1, Var.create 2, Var.create 3, Var.create 4)

  let graph =
    eval (env [(&quot;a&quot;, var a); (&quot;b&quot;, var b); (&quot;c&quot;, var c); (&quot;d&quot;, var d)]) expr

  let () = Format.printf &quot;First evaluation@.&quot;

  let () = assert (get graph = -4)

  let () = Var.set a 3

  let () = Format.printf &quot;Second evaluation@.&quot;

  let () = assert (get graph = -2)
end</code></pre><p>Here, instead of evaluating the expession, <code>Incremental.eval</code> builds a graph with inputs the variables <code>a,b,c,d</code> and output the node <code>graph</code>. We force the evaluation of a node by calling <code>Cgraph.get</code> on that node. This triggers the recursive evaluation of all <b>and only</b> the nodes which are not up to date.</p><p>Evaluating this piece of code prints the following:</p><pre>    Incremental computation
    First evaluation
    1 + 2
    3 + 4
    3 + -7
    Second evaluation
    3 + 2
    5 + -7</pre><p>Notice how the node that didn't need to be recomputed wasn't!</p></header></section><section><header><h2 id="api"><a href="#api" class="anchor"></a>API documentation</h2></header><dl><dt class="spec module" id="module-Var"><a href="#module-Var" class="anchor"></a><code><span class="keyword">module</span> <a href="Var/index.html">Var</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p><code>Var</code> is the module type of variables, which are the first kind of input nodes available to users.</p></dd></dl><dl><dt class="spec module" id="module-Gen"><a href="#module-Gen" class="anchor"></a><code><span class="keyword">module</span> <a href="Gen/index.html">Gen</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p><code>Gen</code> is the module type of generators, which are the second kind of input nodes available to users. These correspond to streams of values.</p></dd></dl><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> <span>!'a t</span></code></dt><dd><p>The type of nodes.</p></dd></dl><dl><dt class="spec value" id="val-var"><a href="#val-var" class="anchor"></a><code><span class="keyword">val</span> var : <span><span class="type-var">'a</span> <a href="Var/index.html#type-t">Var.t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p>Inject a variable as a node.</p></dd></dl><dl><dt class="spec value" id="val-gen"><a href="#val-gen" class="anchor"></a><code><span class="keyword">val</span> gen : <span><span class="type-var">'a</span> <a href="Gen/index.html#type-t">Gen.t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p>Inject a generator as a node.</p></dd></dl><dl><dt class="spec value" id="val-get"><a href="#val-get" class="anchor"></a><code><span class="keyword">val</span> get : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>get n</code> computes the currenet value associated to <code>n</code>. This might recursively trigger the recomputation of all currently invalidated node on which <code>n</code> depends.</p></dd></dl><dl><dt class="spec value" id="val-return"><a href="#val-return" class="anchor"></a><code><span class="keyword">val</span> return : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>return x</code> is a node that holds the constant value <code>x</code>. Can never be invalidated.</p></dd></dl><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>map n f</code> is a node whose value is equal to <code>f</code> applied to the value of <code>n</code>.</p></dd></dl><dl><dt class="spec value" id="val-map2"><a href="#val-map2" class="anchor"></a><code><span class="keyword">val</span> map2 : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'c</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>map2 n1 n2 f</code> is a node whose value is equal to <code>f</code> applied to the values of <code>n1</code> and <code>n2</code>.</p></dd></dl><dl><dt class="spec value" id="val-map3"><a href="#val-map3" class="anchor"></a><code><span class="keyword">val</span> map3 : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'c</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'d</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'d</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p>See <code>map2</code>.</p></dd></dl><dl><dt class="spec value" id="val-bind"><a href="#val-bind" class="anchor"></a><code><span class="keyword">val</span> bind : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>bind m f</code> allows to construct graphs dynamically. Use only if you really need it, as this induces the extra overhead of garbage collecting nodes.</p></dd></dl><dl><dt class="spec value" id="val-if_"><a href="#val-if_" class="anchor"></a><code><span class="keyword">val</span> if_ : <span>bool <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>if c t f</code> constructs a node whose value is equal to that of <code>t</code> if <code>c</code> has value <code>true</code>, or that of <code>f</code> in the other case.</p></dd></dl><dl><dt class="spec value" id="val-on_update"><a href="#val-on_update" class="anchor"></a><code><span class="keyword">val</span> on_update : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Attach an arbitrary callback to a node, to be called when the value in the node is updated.</p></dd></dl><dl><dt class="spec module" id="module-Infix"><a href="#module-Infix" class="anchor"></a><code><span class="keyword">module</span> <a href="Infix/index.html">Infix</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Infix operators, for convenience.</p></dd></dl><dl><dt class="spec type" id="type-ex"><a href="#type-ex" class="anchor"></a><code><span class="keyword">type</span> ex</code></dt><dd><p>Existentially packed nodes. Not useful to end users.</p></dd></dl><dl><dt class="spec value" id="val-ex"><a href="#val-ex" class="anchor"></a><code><span class="keyword">val</span> ex : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="index.html#type-ex">ex</a></code></dt></dl><dl><dt class="spec module" id="module-Internal"><a href="#module-Internal" class="anchor"></a><code><span class="keyword">module</span> <a href="Internal/index.html">Internal</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Functions useful for debugging.</p></dd></dl></section></div></body></html>