<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Cgraph (prbnmcn-cgrph.Cgraph)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">prbnmcn-cgrph</a> &#x00BB; Cgraph</nav><header class="odoc-preamble"><h1>Module <code><span>Cgraph</span></code></h1><p>Cgraph: a simple library for incremental computation</p></header><nav class="odoc-toc"><ul><li><a href="#introduction">Introduction</a></li><li><a href="#example">Example</a></li><li><a href="#api">API documentation</a></li></ul></nav><div class="odoc-content"><h2 id="introduction"><a href="#introduction" class="anchor"></a>Introduction</h2><p>The API exposed by Cgraph allows to construct a DAG where nodes hold functions. Users describe computations using this API; the library ensures that upon change of input, only the minimal amount of computation has to be performed to update the output. See the work by Umut Acar et al, and others for more details.</p><h2 id="example"><a href="#example" class="anchor"></a>Example</h2><p>We illustrate the library by considering the toy problem of evaluating an arithmetic expression. We consider a very simple data type, with just addition and negation. Variables are represented by strings and we'll use a string map to represent the environment in which the expression is evaluated.</p><pre><code>module String_map = Map.Make (String)

type expr = Var of string | Add of expr * expr | Neg of expr</code></pre><p>In the rest, we'll consider the following expression, corresponding to <code>(a + b) - (c + d)</code>.</p><pre><code>let expr = Add (Add (Var &quot;a&quot;, Var &quot;b&quot;), Neg (Add (Var &quot;c&quot;, Var &quot;d&quot;)))</code></pre><p>In order to trace the evaluation of the naive vs incrementalized evaluators, we instrument addition and negation with printfs.</p><pre><code>let ( + ) x y =
  Format.printf &quot;%d + %d@.&quot; x y ;
  x + y

let ( - ) x =
  Format.printf &quot;- %d@.&quot; x ;
  -x</code></pre><p>The <code>Non_incremental</code> module defines a straightforward evaluator for our small language and evaluates it, changing the value of the variable <code>&quot;a&quot;</code> the second time.</p><pre><code>let env l = String_map.of_seq (List.to_seq l)

module Non_incremental = struct
  let () = Format.printf &quot;Non incremental computation@.&quot;

  let rec eval (env : int String_map.t) expr =
    match expr with
    | Var s -&gt; String_map.find s env
    | Add (l, r) -&gt; eval env l + eval env r
    | Neg e -&gt; -eval env e

  let () = Format.printf &quot;First evaluation@.&quot;

  let () =
    assert (eval (env [(&quot;a&quot;, 1); (&quot;b&quot;, 2); (&quot;c&quot;, 3); (&quot;d&quot;, 4)]) expr = -4)

  let () = Format.printf &quot;Second evaluation@.&quot;

  let () =
    assert (eval (env [(&quot;a&quot;, 3); (&quot;b&quot;, 2); (&quot;c&quot;, 3); (&quot;d&quot;, 4)]) expr = -2)
end</code></pre><p>Evaluating this piece of code prints the following:</p><pre>    Non incremental computation
    First evaluation
    3 + 4
    1 + 2
    3 + -7
    Second evaluation
    3 + 4
    3 + 2
    5 + -7</pre><p>Let's reiterate the experiment, using the library.</p><pre><code>module Incremental = struct
  let () = Format.printf &quot;Incremental computation@.&quot;

  open Cgraph

  let rec eval (env : int t String_map.t) expr =
    match expr with
    | Var s -&gt; String_map.find s env
    | Add (l, r) -&gt; map2 (eval env l) (eval env r) ( + )
    | Neg e -&gt; map (eval env e) ( ~- )

  let (a, b, c, d) = (Var.create 1, Var.create 2, Var.create 3, Var.create 4)

  let graph =
    eval (env [(&quot;a&quot;, var a); (&quot;b&quot;, var b); (&quot;c&quot;, var c); (&quot;d&quot;, var d)]) expr

  let () = Format.printf &quot;First evaluation@.&quot;

  let () = assert (get graph = -4)

  let () = Var.set a 3

  let () = Format.printf &quot;Second evaluation@.&quot;

  let () = assert (get graph = -2)
end</code></pre><p>Here, instead of evaluating the expession, <code>Incremental.eval</code> builds a graph with inputs the variables <code>a,b,c,d</code> and output the node <code>graph</code>. We force the evaluation of a node by calling <code>Cgraph.get</code> on that node. This triggers the recursive evaluation of all <b>and only</b> the nodes which are not up to date.</p><p>Evaluating this piece of code prints the following:</p><pre>    Incremental computation
    First evaluation
    1 + 2
    3 + 4
    3 + -7
    Second evaluation
    3 + 2
    5 + -7</pre><p>Notice how the node that didn't need to be recomputed wasn't!</p><h2 id="api"><a href="#api" class="anchor"></a>API documentation</h2><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>!'a t</span></span></code></div><div class="spec-doc"><p>The type of nodes.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-undo_info" class="anchored"><a href="#type-undo_info" class="anchor"></a><code><span><span class="keyword">type</span> undo_info</span></code></div><div class="spec-doc"><p><code>undo_info</code> holds information useful to perform limited backtracking of certain computations. See <a href="#val-undo"><code>undo</code></a>.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Var" class="anchored"><a href="#module-Var" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Var/index.html">Var</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p><code>Var</code> is the module type of variables, which are the simplest kind of input nodes available to users.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Gen" class="anchored"><a href="#module-Gen" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Gen/index.html">Gen</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p><code>Gen</code> is the module type of generators, which are the second kind of input nodes available to users. These correspond to streams of values.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-var" class="anchored"><a href="#val-var" class="anchor"></a><code><span><span class="keyword">val</span> var : <span><span><span class="type-var">'a</span> <a href="Var/index.html#type-t">Var.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Inject a variable as a node.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-gen" class="anchored"><a href="#val-gen" class="anchor"></a><code><span><span class="keyword">val</span> gen : <span><span><span class="type-var">'a</span> <a href="Gen/index.html#type-t">Gen.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Inject a generator as a node.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get" class="anchored"><a href="#val-get" class="anchor"></a><code><span><span class="keyword">val</span> get : <span>?u:<a href="#type-undo_info">undo_info</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>get n</code> computes the current value associated to <code>n</code>. This might recursively trigger the recomputation of all currently invalidated node on which <code>n</code> depends.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-return" class="anchored"><a href="#val-return" class="anchor"></a><code><span><span class="keyword">val</span> return : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>return x</code> is a node that holds the constant value <code>x</code>. Can never be invalidated.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-map" class="anchored"><a href="#val-map" class="anchor"></a><code><span><span class="keyword">val</span> map : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>map n f</code> is a node whose value is equal to <code>f</code> applied to the value of <code>n</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-map2" class="anchored"><a href="#val-map2" class="anchor"></a><code><span><span class="keyword">val</span> map2 : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'c</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>map2 n1 n2 f</code> is a node whose value is equal to <code>f</code> applied to the values of <code>n1</code> and <code>n2</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-map3" class="anchored"><a href="#val-map3" class="anchor"></a><code><span><span class="keyword">val</span> map3 : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'c</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'d</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'d</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>See <code>map2</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-map_array" class="anchored"><a href="#val-map_array" class="anchor"></a><code><span><span class="keyword">val</span> map_array : <span><span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> array</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span><span class="type-var">'a</span> array</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>See <code>map2</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-bind" class="anchored"><a href="#val-bind" class="anchor"></a><code><span><span class="keyword">val</span> bind : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>bind m f</code> allows to construct graphs dynamically. Use only if you really need it, as this induces the extra overhead of garbage collecting nodes.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-if_" class="anchored"><a href="#val-if_" class="anchor"></a><code><span><span class="keyword">val</span> if_ : <span><span>bool <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>if c t f</code> constructs a node whose value is equal to that of <code>t</code> if <code>c</code> has value <code>true</code>, or that of <code>f</code> in the other case.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-on_update" class="anchored"><a href="#val-on_update" class="anchor"></a><code><span><span class="keyword">val</span> on_update : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Attach an arbitrary callback to a node, to be called when the value in the node is updated.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-undo" class="anchored"><a href="#val-undo" class="anchor"></a><code><span><span class="keyword">val</span> undo : <span><a href="#type-undo_info">undo_info</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>undo</code> allows to revert the underlying state of a value after having performed a call to <a href="Var/index.html#val-set_with_undo"><code>Var.set_with_undo</code></a> followed by a call to <a href="#val-get"><code>get</code></a>. Note that some side-effects that cannot be observed by the user might not be reverted.</p><p>Interleaving other calls to the public API might result in undefined behaviour.</p><p>This must be considered an unsafe feature: use at your own peril.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Infix" class="anchored"><a href="#module-Infix" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Infix/index.html">Infix</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Infix operators, for convenience.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-ex" class="anchored"><a href="#type-ex" class="anchor"></a><code><span><span class="keyword">type</span> ex</span></code></div><div class="spec-doc"><p>Existentially packed nodes. Not useful to end users.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-ex" class="anchored"><a href="#val-ex" class="anchor"></a><code><span><span class="keyword">val</span> ex : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ex">ex</a></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Internal" class="anchored"><a href="#module-Internal" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Internal/index.html">Internal</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Functions useful for debugging.</p></div></div></div></body></html>